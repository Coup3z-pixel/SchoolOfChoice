\documentclass[12pt]{article}
\usepackage{amsmath}
\usepackage{amstext}
\usepackage{amssymb}
\usepackage{amsthm}
\makeatletter
\usepackage{graphicx,epsf}
\usepackage{times,float}
\usepackage{enumerate}
\usepackage[round,comma]{natbib}
\usepackage[colorlinks=true,citecolor=blue]{hyperref}
\usepackage{bm}
\usepackage{multirow}
%\usepackage{blkarray}
\usepackage{rotating}

\setlength{\textwidth}{6.4in} \setlength{\textheight}{8.5in}
\setlength{\topmargin}{-.2in} \setlength{\oddsidemargin}{.1in}
\renewcommand{\baselinestretch}{1.3}

\theoremstyle{definition}
\newtheorem{thm}{Theorem}
\newtheorem*{thm*}{Theorem}
\newtheorem{prop}{Proposition}
\newtheorem{cor}{Corollary}
\newtheorem{lem}{Lemma}
\newtheorem*{lem*}{Lemma}
\newtheorem{claim}{Claim}
\newtheorem{rem}{Remark}
\newtheorem{ex}{Example}
\newtheorem{fact}{Fact}
\newtheorem*{fact*}{Fact}
\newtheorem{remark}{Remark}


\newcommand{\rR}{\mathrel{R}}
\newcommand{\rP}{\mathrel{P}}
\newcommand{\real}{\mathbb{R}}
\newcommand{\norev}{\medskip \centerline{\textbf{No Revisions Below}} \medskip}
\renewcommand{\Re}{\mathbb{R}}
\newcommand{\In}{\mathbb{Z}}

\newcommand{\bare}{\overline{e}}
\newcommand{\barl}{\overline{l}}

\newcommand{\bq}{\mathbf{q}}

\newcommand{\cE}{\mathcal{E}}
\newcommand{\cH}{\mathcal{H}}
\newcommand{\cM}{\mathcal{M}}
\newcommand{\cP}{\mathcal{P}}
\newcommand{\cX}{\mathcal{X}}

\newcommand{\dr}{{\dot r}}
\newcommand{\dq}{{\dot q}}
\newcommand{\dg}{{\dot g}}
\newcommand{\ddp}{{\dot p}}

\newcommand{\hA}{{\hat A}}
\newcommand{\hO}{{\hat O}}

\newcommand{\halpha}{{\hat \alpha}}

\newcommand{\ta}{{\tilde a}}
\newcommand{\te}{{\tilde e}}
\newcommand{\tn}{{\tilde n}}

\newcommand{\tB}{{\tilde B}}

\newcommand{\bark}{{\overline k}}
\newcommand{\bart}{{\overline t}}

\newcommand{\varep}{\varepsilon}

\newcommand{\bone}{\mathbf{1}}

\begin{document}

\title{GCPS Schools: A User's Guide}

\author{Andrew McLennan\footnote{School of Economics, University of
    Queensland, {\tt a.mclennan@economics.uq.edu.au}}}

\date{\today}

\maketitle

\begin{abstract}
This document provides a brief introduction to the software package GCPS Schools.
\end{abstract}

% \pagebreak

\section{Introduction}

In the paper ``An Efficient School Choice Mechanism Based on a
Generalization of Hall's Marriage Theorem'' (joint with Shino Takayama
and Yuki Tamura) we describe a new algorithm for school choice, along
with its theoretical foundations.  This algorithm has been implemented
in the software package \emph{GCPS Schools} as an executable
\texttt{gcps}.  The software package also contains two other
executables \texttt{make\_ex} and \texttt{purify}.  The first of these
generates example school choice problems of the sort that might occur
in large school districts.  The second program passes from a matrix of
assignment probabilities to a random pure assignment with a
distribution that averages to the given matrix of probabilities.
These programs provide the basic computational resources required to
apply our mechanism, and perhaps in some cases they will suffice.
However, our primary hope is that the underlying code will be a useful
starting point for further software development.

This document describes these programs, from the point of view of a
user.  It doesn't assume that the reader has already read our paper,
but of course we are leaving out lots of relevant information.

\section{\texttt{gcps}}

To begin with we describe a simple example of an input file, which the
application \texttt{gcps} expects to find in a file called
\texttt{schools.scp} in the current directory.  (If there is no such
file \texttt{gcps} simply complains and quits.)

\begin{obeylines}\texttt{
/* This is a sample introductory comment. */
There are 4 students and 3 schools
The vector of quotas is (1,2,1)
The priority matrix is
     1     1     1
     1     0     1
     1     1     1
     1     1     1
The students numbers of ranked schools are (3,2,3,3)
The preferences of the students are
1:  1  2  3  
2:  1  3  
3:  1  2  3  
4:  1  2  3  
The priority thresholds of the schools are
1   1   1   
  }
\end{obeylines}

\medskip

Our input files begin with a comment between \texttt{/*} and
\texttt{*/}.  This is purely for your convenience, and the comment can
be of any length, and provide whatever information is useful to you,
but it is mandatory insofar as the computer will insist that the first
two characters of the file are \texttt{/*} and will only start
extracting information after it sees the \texttt{*/}.  The computer
divides the remainder into ``generalized white space'' (in addition to
spaces, tabs, and new lines, `\texttt{(}', `\texttt{)}', and
`\texttt{,}' are treated as white space) and ``tokens,'' which are
sequences of characters without any of the generalized white space
characters.  Tokens are either prescribed words, numbers, or student
tags (a student number followed by `\texttt{:}') and everything must
be more or less exactly as shown below, modulo white space, so, for
example, the first line must not be \texttt{There are 3 students and 1
  school}, but it could be \texttt{There are 3 students and \ \ 1
  schools}.

The next line gives the quotas (i.e., the capacities) of the schools,
so school 2 has two seats, and the other two schools each have one
seat.  Here we see the convenience of making `\texttt{(}',
`\texttt{)}', and `\texttt{,}' white space characters: otherwise we
would have had to write \texttt{The vector of quotas is 1 2 1}.

Our treatment of priorities is somewhat different from what is typical
in the school choice literature, where the priority is thought of as
the ``utility'' the school gets from a student, and is often required
to come from a strict ranking of the students.  At this stage a
student's priority at a school is either 1 if she is allowed to attend
the school, and may be assigned a seat there, and otherwise it is 0.
(We'll talk about more complicated priorities later.)  A student's
priority at a school may be 0 because she is not qualified (it is a
single sex school for boys, or her test scores are too low) or it may
be 0 because the student prefers a seat at her ``safe school'' (as we
explain below) and can insist on receiving a seat at a school that is
no worse for her than that.

The next line provides information (for each student, the number of
schools for which she has priority 1) that the computer could figure
out for itself, but we prefer to confirm that whatever person or
software prepared the input knew what they were doing.  After that
come the students' preferences: for each student, that student's tag
followed by the schools she might attend, listed from best to worst.
Finally, there are the schools' minimum priorities for admission,
which in this context are all 1: a student is good enough to admit to
a school if her priority for that school is 1 and not
otherwise. (Again, we'll talk about more complex situations later.)
The collection of information provided by an input file is a
\emph{school choice problem}.

What the software does (primarily) is compute a matrix of assignment
probabilities.  For our particular example \texttt{gcps} gives the
following output:
\medskip
\begin{obeylines}\texttt{
The allocation is:
\ \ \ \ \ 1:    \    2:  \      3:
1:      0.25     0.67     0.08
2:      0.25     0.00     0.75
3:      0.25     0.67     0.08
4:      0.25     0.67     0.08
}
\end{obeylines} \noindent

\smallskip
Note that the sum of the entries in each row is 1 and the sum of the
entries in each school's column is that school's quota.  In general
the sum of the quotas may exceed the number of students, in which case
we require that the sum of the entries in each school's column does
not exceed that school's quota. An assignment of probabilities with
these properties --- each student's total assignment is 1 and no
school is overassigned --- is a \emph{feasible allocation}.  

Our mechanism is based on the ``simultaneous eating'' algorithm of
\cite{bm01} for probabilistic allocation of objects, as generalized by
\cite{balbuzanov22jet}.  In our example each student consumes
probability of a seat in her favorite school (school 1) until that
resource is exhausted at time 0.25, at which point each student
switches to the next best thing.  This continues until school 2 is
also exhausted, after which all finish up by consuming probability of
a seat in school 3.

This makes good sense if the schools simply fill up one by one, as in
this example, but is that always what happens?  Actually, no.  To help
understand this we first introduce a new concept, the ``safe school.''
The idea is that each student has one school, say the closest school
or the school that a sibling attends, to which she is guaranteed
admission if she insists.  (It is a major advantage of our mechanism
that we can provide such a guarantee.)  Each student submits a ranking
of schools that she is eligible for and (weakly) prefers to the safe
school, and her priority is 1 at those schools and 0 at all others.

Now suppose that there are two schools, say 1 and 2, that are quite
popular.  Some students have school 1 as their safe school, but prefer
2, and some students have school 2 as their safe school, but prefer 1.
There are also some students who have other safe schools, but prefer
either 1 or 2, or both.  As the students consume probability at their
favorite schools, there can come a time at which schools 1 and 2
together only have enough remaining capacity to serve the students who
can insist on going to one of these two schools, even though school 1
still has excess capacity if it can ignore the students who have 1 as
their safe school but prefer 2 and the students who have 2 as their
safe school but prefer 1, and similarly for school 2.  When this
happens we say that the set of schools $P = \{1,2\}$ has become
\emph{critical}.

At this time further consumption of capacity at schools 1 and 2 is
restricted to those students who cannot be assigned to other schools,
so further consumption of these schools is denied to students who do
not have 1 or 2 as their safe school, and also to students who have 1
or 2 as their safe school but prefer some third school that is still
available.  For each of the latter students the least preferred of the
schools she is willing to attend that is still available becomes the
new safe school.

More generally, let $P$ be a set of schools, and let $J_P$ be the set
of students whose priorities for all schools outside of $P$ are 0.
For any $i \in J_P$, a feasible allocation must assign probability 1
to student $i$ receiving a seat in $P$, so a necessary condition for
the existence of a feasible allocation is that the total capacity of
the schools in $P$ is not less than the number of students in $J_P$.
In fact this condition is sufficient for the existence of a feasible
allocation: if, for each set of schools $P$, the total capacity of the
schools in $P$ is not less than the number of students in $J_P$, then
a feasible allocation exists.  This is not an obvious or trivial
result, and a somewhat more general version of it is one of the main
points of our paper.  This result extends to situations where the
resources have already been partially allocated: if, for each set of
schools $P$, the total remaining capacity of the schools in $P$ is not
less than the total remaining demand of students in $J_P$ (where this
set is defined in relation to the current partial allocation) then
there is an allocation of the remaining resources that gives a
feasible allocation.

We can now describe the algorithm in a bit more detail.  At each time
each student is consuming probability of a seat at the favorite school
among those that are still available to her.  This continues until the
first time that there is a set of schools $P$ such that the remaining
capacity is just sufficient to meet the needs of the students in the
set $J_P$ of students who no longer have access to any schools outside
of $P$.  At this point the problem divides into two subproblems, one
corresponding to the sets $P$ and $J_P$ and the other corresponding to
the complements of these sets.  These problems have the same form as
the original problem, and can be treated algorithmically in the same
way, so the algorithm can descend recursively to smaller and smaller
subproblems until a feasible allocation has been fully computed.


\section{\texttt{purify}} \label{sec:Implementation}

The output of \texttt{gcps} is a matrix of assignment probabilities, as shown in the example below.

\begin{obeylines}\texttt{
\ \ \ \ \ $A$:    \     $B$:  \      $C$:
1:      0.25     0.67     0.08
2:      0.25     0.00     0.75
3:      0.25     0.67     0.08
4:      0.25     0.67     0.08
}
\end{obeylines} \noindent
(Now, to avoid confusion, the schools are $A$, $B$, and
$C$.)

\medskip
Generating a random deterministic assignment with a probability
distribution that averages to this matrix is called
\emph{implementation} by \cite{bckm13aer}.  The executable
\texttt{purify} reads a feasible matrix $m$ of assignment
probabilities from a file \texttt{allocate.mat}, which must have the
form of the output of \texttt{gcps}, and it produces a random
deterministic allocation with a suitable distribution, using an
algorithm of \cite{bckm13aer}, as it applies to our somewhat simpler
framework.

We can illustrate the algorithm using the feasible allocation shown
above.  We consider a cyclic path alternating between students and
schools, say $1 \to C \to 3 \to A \to 1$, such that the entries of the
matrix for $(1,C)$, $(3,C)$, $(3,A)$, and $(1,A)$ are all strictly
between $0$ and $1$.  If we add $0.08$ to the entries for $(1,C)$ and
$(3,A)$ while subtracting $0.08$ from the entries for $(3,C)$ and
$(1,A)$, we obtain
\begin{obeylines}\texttt{
\ \ \ \ \ $A$:    \     $B$:  \  $C$:
1:      0.17     0.67     0.17
2:      0.25     0.00     0.75
3:      0.33     0.67     0.00
4:      0.25     0.67     0.08
}
\end{obeylines} \noindent
(Recall that $0.08$, $0.17$, and $0.33$ are really $\tfrac{1}{12}$,
$\tfrac16$ and $\tfrac13$.)  This is also a feasible allocation.  We
could also subtract $0.08$ from the entries for $(1,C)$ and $(3,A)$
while adding $0.08$ the entries for $(3,C)$ and $(1,A)$, thereby
obtaining the feasible allocation
\begin{obeylines}\texttt{
\ \ \ \ \ $A$:    \     $B$:  \      $C$:
1:      0.33     0.67     0.00
2:      0.25     0.00     0.75
3:      0.17     0.67     0.17
4:      0.25     0.67     0.08
}
\end{obeylines} \noindent
Supposing that we decide which of these to do by flipping a coin, we
could then look for another cycle and repeat the process.  Each step
reduces the number of entries that are strictly between $0$ and $1$,
so we would eventually arrive at a deterministic assignment.

We now give a more formal explanation of the algorithm, as implemented
in \texttt{implement.h}, \texttt{implement.c}, and \texttt{purify.c}.
There is a directed graph whose nodes are the students, the schools,
and a \emph{sink}.  The graph has an arc from each student to each
school, and an arc from each school to the sink.  A \emph{flow} is an
assignment of a positive number to each arc such that for each
student, the sum of the flows to all schools is $1$, and for each
school the sum of the flows from all students is equal to the flow
from that school to the sink.  A matrix of assignment probabilities
$m$ has an associated flow $f$ in which the flow from each student to
each school is the probability that the student receives a seat in the
school, and the flow from the school to the sink is the sum of the
school's assignment probabilities.

There is a subgraph consisting of all arcs whose flows are not
integers.  A key point is that for any node that is an endpoint of one
of the arcs in the subgraph, there is another node in the subgraph
that also has that node as an endpoint.  For each student, this is
obvious because the sum of the student's assignment probabilities is
one.  If the sum of the flows into a school is an integer, and one of
these flows is not an integer, then there must be another flow into
the school that is not an integer.  If the sum of the flows into a
school is not an integer, then one of the flows into the school is not
an integer, and the flow from the school to the sink is not an
integer.  The sum of the flows into the sink is the sum of the flows
out of the students, which is the number of students, hence an
integer, so if the flow from one of the schools to the sink is not an
integer, there must be another such school.

Consequently the subgraph has a \emph{cycle}, which is a sequence of
distinct nodes $n_1, \ldots, n_k$ such that $k > 2$ and, for each $i =
1, \ldots, k$, $n_i$ and $n_{i+1}$ are the endpoints of an arc in the
subgraph.  (We are treating the indices as integers mod $k$, so $k + 1
= 1$.)  The algorithm for finding a cycle (whose correctness is the
proof of the existence of a cycle) works in an obvious manner.
Beginning with $n_1$ and $n_2$ that are the endpoints of an arc in the
subgraph, it finds $n_3 \ne n_1$ such that $n_2$ and $n_3$ are the
endpoints of an arc in the subgraph.  In general, after finding $n_i$
such that $n_{i-1}$ and $n_i$ are the endpoints of an arc in the
subgraph, the algorithm asks whether there is $j = 1, \ldots, i-2$
such that $n_i = n_j$, in which case $n_j, \ldots, n_{i-1}$ is the
desired cycle, and otherwise it finds $n_{i+1} \ne n_{i-1}$ such that
$n_i$ and $n_{i+1}$ are the endpoints of an arc in the subgraph.
Since there are finitely many nodes, the process must eventually halt.

Given a cycle $n_1, \ldots, n_k$, for each $i = 1, \ldots, k$ we say
that $n_in_{i+1}$ is a \emph{forward arc} if $n_i$ is a student and
$n_{i+1}$ is a school, or if $n_i$ is a school and $n_{i+1}$ is the
sink, and otherwise we say that $n_{i+1}n_i$ is a \emph{backward arc}.
For any real number $\delta$, if we modify $f$ by adding a constant
$\delta$ to the flow of each forward arc while subtracting $\delta$
from the flow of each backward arc, the result $f^\delta$ is a new
flow, because for each student the sum of outward flows is $1$, and
for each school the sum of flows from students to the school is the
flow from the school to the sink.

Let $\alpha$ be the smallest positive number such that $f^\alpha$ has
at least one more integer entry than $f$, and let $\beta$ be the
smallest positive number such that $f^{-\beta}$ has at least one more
integer entry than $f$.  Then $f = \tfrac{\beta}{\alpha +
  \beta}f^\alpha + \tfrac{\alpha}{\alpha + \beta}f^{-\beta}$.  Let
$m^\alpha$ and $m^{-\beta}$ be the restrictions of $f^\alpha$ and
$f^{-\beta}$ to the arcs from students to schools.  It is easy to see
that $m^\alpha$ and $m^{-\beta}$ are feasible allocations: their
entries lie in $[0,1]$, and the sums of the entries for each student
and each school are the corresponding sums for $m$.  The algorithm
passes from $m$ and $f$ to $m^\alpha$ and $f^{\alpha}$ with
probability $\tfrac{\beta}{\alpha + \beta}$, and to $m^{-\beta}$ and
$f^{-\beta}$ with probability $\tfrac{\alpha}{\alpha + \beta}$.
Whichever of $m^\alpha$ and $m^{-\beta}$ is chosen, if it is not a
deterministic assignment, then the process is repeated.

\section{\texttt{make\_ex}}

Development of this sort of software requires testing under at least
somewhat realistic conditions.  The utility \texttt{make\_ex} produces
examples of input files for \texttt{gcps} that reflect the
geographical dispersion of school districts with many schools, and the
idiosyncratic nature of school quality and student preferences.

One of the files produced by \texttt{make\_ex} begins as follows:
\begin{obeylines}\texttt{
    /* This file was generated by make\_ex with 20 schools,
    4 students per school, capacity 5 for all schools,
    school valence standard deviation 1.00,
    and idiosyncratic standard deviation 1.00. */
}
\end{obeylines} \noindent
In this example there are 20 schools that are spaced evenly around a
circle of circumference 20.  Since there are 4 students per school,
there are 80 students whose homes are spaced evenly around the circle.
Each student's safe school is the school closest to her home.  A
student's utility for a school is the sum of the school's valence and
an idiosyncratic shock, minus the distance from the student's home to
the school.  Each school's valence is a normally distributed random
variable with mean 0.0 and standard deviation 1.0, and for each
student-school pair the idiosyncratic shock is a normally distributed
random variable with mean 0.0 and standard deviation 1.0.  All of
these random variables are independent.  The program passes from the
utilities to an input for \texttt{gcps} by finding the ranking, for
each student, of the schools for which the student's utility is at
least as large as the utility of the safe school.

Near the beginning of the file \texttt{example.c} there are the following lines:
\begin{obeylines}\texttt{
  int no\_schools = 20;
  int no\_students\_per\_school = 4;
  int school\_capacity = 5;
  double school\_valence\_std\_dev = 1.0;
  double idiosyncratic\_std\_dev = 1.0;
}
\end{obeylines} \noindent
Even for someone who knows nothing about the C programming language,
this is pretty easy to understand.  The keywords \texttt{int} and
\texttt{double} are data types for integers and floating point
numbers.  Each line assigns a value to some variable.  If you would
like to generate examples with different parameters, the way to do
that is to change the parameters by editing \texttt{example.c}, run
\texttt{make}, and then issue a command like \texttt{make\_ex >
  my\_file.scp}.  For example, to diminish the relative importance of
travel costs one can increase \texttt{school\_valence\_std\_dev} and
\texttt{idiosyncratic\_std\_dev}.

This illustrates an important point concerning the relationship
between this software and its users.  Most softwares have interfaces
with the user that neither require nor allow the user to edit the
source code, but to create such an interface here would be
counterproductive. It would add complexity to the source code that had
nothing to do with the underlying algorithms.  More importantly, the
main purpose of this software is to provide a starting point for the
user's own programming effort in adapting it to the particular
requirements and idiosyncratic features of the user's school choice
setting.  Our algorithms are not very complicated, and someone
familiar with C should hopefully not have a great deal of difficulty
figuring out what is going on and then bending it to her purposes.
Starting to look at and edit the source code as soon as possible is a
first step down that road.


\section{Finer Priorities}

To appreciate the issue discussed in this section one needs to
understand some of the history of other school choice mechanisms.
Instead of matching students to seats in schools, it is perhaps more
intuitive to consider matching a finite set of boys with a finite set
of girls, who each have strict preferences over potential partners and
remaining single.

The boy-proposes version of the famous deferred acceptance algorithm
begins with each boy proposing to his favorite girl, if there is one
he prefers to being alone.  Each girl rejects all proposals that are
less attractive than being alone, and if she has received more than
one acceptable proposal, she holds on to her favorite and rejects all
the others.  In each subsequent round, each boy who was rejected in
the previous round proposes to his favorite among the girls who have
not yet rejected him, if one of these is acceptable. Each girl now has
a number of new proposals, and possibly the proposal she brought
forward from the previous round.  She retains her favorite of these,
if it is acceptable, rejecting all others.  This procedure is repeated
until there is a round with no rejections, at which point each girl
holding a proposal pairs up with the boy whose proposal she is
holding. This mechanism was first proposed in the academic literature
by \cite{GaSh62}, but it turned out that it had already been used for
several years to match new graduates of medical schools with
residencies.  For almost twenty years it has been used in school
matching, with the students proposing and the seats in the various
schools rejecting, and it is now in widespread use around the world.

The key point for us is that this mechanism is not well defined unless
both sides have strict preferences.  In the context of school
matching, the schools' preferences are called \emph{priorities}.  If
these priorities are not actual reflections of society's values, this
can result in inefficiency.  For example, if Carol School's priorities
rank Bob above Ted while Alice School's priorities rank Ted above Bob,
then we could have an assignment in which Bob envies Ted's seat at
Alice School while Ted envies Bob's seat at Carol School.  This sort
of inefficiency can be quantitatively important, and a major advantage
of our mechanism is that it is efficient, in an even stronger sense
than not allowing outcomes in which improving trades are possible.

However, there are cases in which the schools' priorities do reflect
actual values.  In China, for example, each student's priority at all
schools is the score on a standardized test.  A consequence of this,
under deferred acceptance, is that, in effect, each school has an exam
score cutoff, accepting all students above the cutoff, rejecting all
students below the cutoff, and randomizing (roughly speaking) over
students right at the cutoff.  Our main concern in this section is to
explain how our mechanism can achieve similar outcomes.

The first point is that our input files can have a richer structure
than our original example suggests, as illustrated by the input on the
next page.  The priorities can be arbitrary nonnegative integers.  A
student having a priority of 0 at a particular school is understood as
indicating that the student cannot be assigned there, either because
she is not qualified or because she prefers her safe school.  A
student's safe school can be indicated by giving the student the
highest possible priority at that school.  The computer passes from
this input to a school choice problem in which the priority of a
student at a school is 1 if her priority in the input is not less than
the school's priority threshold, and it is 0 otherwise, each school's
priority threshold is set to 1, and each student's preference is
truncated by eliminating schools she is not eligible for.  Applying
this procedure to the input below gives our original example.

It is possible to repeatedly adjust the schools' priority thresholds
to achieve a desired effect.  For example, suppose there are two
selective schools, and the school district would like it to be the
case that a well qualified student is almost certain to receive a seat
in one of them if that is what she wants, and at the same time these
schools do not have more than a small amount of unused capacity.  One
may raise the priority threshold of a school if many students are
receiving some probability of admission and lower the threshold if its
seats are not being filled.  Of course changing the priority threshold
at one of the schools will effect demand for the other school, so
repeated adjustment of the priority thresholds of all the schools may
be required to achieve a desirable result.  (Automating this iterative
adjustment process may require the development of a version of
\texttt{gcps} that can accept parameter inputs, without editing the
source code.  This should be a simple task for an experienced C
programmer.)

\begin{obeylines}\texttt{
/* This is a sample introductory comment. */
There are 4 students and 3 schools
The vector of quotas is (1,2,1)
The priority matrix is
     5     6     9
     2     2     9
     5     4     9
     3     4     9
The students numbers of ranked schools are (3,3,3,3)
The preferences of the students are
1:  1  2  3  
2:  1  2  3  
3:  1  2  3  
4:  1  2  3  
The priority thresholds of the schools are
1   3   5   
  }
\end{obeylines}

Whether it is a good idea to use priorities as the Chinese do is an
extremely complex question.  On the one hand there is an obvious sense
in which it is desirable to provide the best resources to those who
can extract the greatest benefit.  On the other side, the Chinese
system intensifies the intergenerational transmission of advantage,
and there is some education research suggesting that average students
benefit from having talented peers while talented students are not
disadvantaged by having some peers who are ordinary. One could easily
list numerous additional issues.  Balancing various concerns in
practice requires information concerning what would actually happen
under various policy alternatives.  Our mechanism provides a wide
range of alternatives, for which outcomes from existing data can be
easily computed.

\section{What If There Are Many Schools?}

[The material below is inaccurate, and will be superceded as the software develops.]

\norev

As the algorithm was described above, it looked ahead, for each set of
schools $P$, to determine the time at which it would become necessary
to restrict further consumption of schools in $P$ to students in
$J_P$.  This is not unduly burdensome if there are a moderate number
of schools.  (For a ``toy'' example with 20 schools, hence over one
million sets of schools, the algorithm finishes in about 10 seconds.)
But some school choice problems have several dozen or even hundreds of
schools, and will overwhelm the naive version of the algorithm
described above.  There are several things that can be done about
this.

When the software is invoked, the computer looks in the current
directory to see if there is a file called \texttt{related.mat}.  If
it is there, it reads it, expecting it to look as below.  As before
there is an initial comment between the expected initial \texttt{/*}
and the first occurrence of \texttt{*/}.  The next line declares the
number of schools, which must agree with the number of schools of the
given problem, and the line after that declares an parameter called
\texttt{max\_set\_size} which must be a positive integer.  The line
after that declares a \emph{mode}, which may be \texttt{clique},
\texttt{common\_school}, or \texttt{all\_sets}.  After that there are
numbers, separated by generalized white space, each of which must be
either 0 or 1, that are the entries of a square matrix called
\texttt{related} with the number of rows and columns equal to the
number of schools.  The diagonal entries must all be 1, and the matrix
must be symmetric: for all $j$ and $k$, the entries for $(j,k)$ and
$(k,j)$ must agree.
\begin{obeylines}\texttt{
/* This a sample introductory comment */
There are 3 schools
max\_set\_size is 2
clique
1 0 1
0 1 1
1 1 1
}
\end{obeylines} \noindent

We think of \texttt{related} as encoding an undirected graph whose
nodes are the schools: there is an edge between schools $j$ and $k$ if
and only if the $(j,k)$ and $(k,j)$ entries of \texttt{related} are
both 1. A \emph{clique} of such a graph is a set of schools $P$ such
that there is an edge between any two of its elements.  The underlying
assumption (or conjecture, actually) expressed by this file is that,
as the computer descends recursively to smaller and smaller
subproblems, any minimal critical set will be a clique of
\texttt{related}, and will have \texttt{max\_set\_size} or fewer
elements.  In this particular case the candidate critical sets are
singletons and pairs of related nodes.  If the mode is
\texttt{common\_school}, then a candidate critical set is a set of
schools with \texttt{max\_set\_size} or fewer elements that has an
element that is \texttt{related} to every other element of the set.
If the mode is \texttt{all\_sets}, then a candidate critical set is
any set of schools with \texttt{max\_set\_size} or fewer elements.

To help things along a bit, the computer looks for schools whose
capacity will not be exceeded even if every student who ranks it ends
up receiving a seat.  Such a school is never an element of a minimal
critical set, and for such a school the computer changes all of the
entries of the corresponding row and column of \texttt{related} to
zero.

Perhaps the most important thing to say about this is that if the
conjecture expressed by \texttt{related.mat} turns out to be false,
the computer will eventually figure this out and let the user know.
This isn't a disaster: the user simply has to try again with some
different assumption.  Furthermore, if the assumption is correct, the
result of the computation doesn't depend on it in any way.  Thus there
is plenty of scope for trial and error when faced with a large
problem.

Our setup suggests that the specification of \texttt{related.mat} is
the responsibility of the user, and we expect that for some school
choice problems the specification will depend on special features of
the problem, and the user's experience.  For example, schools on the
same subway line might be closer in practice than their physical
distance suggests, and selective or specialized schools may be closely
related to each other even if they are quite distant.

Nevertheless, there are default values that are used if the file
\texttt{related.mat} is not present: a) two schools are
\texttt{related} if there is at least one student who can receive a
seat in either of them; b) \texttt{max\_set\_size} is 6; c) the mode
is \texttt{common\_school}. (Actually, current intuition and
experience suggest that setting \texttt{max\_clique\_size} equal to 4
is already erring on the side of caution.)  As we explain in more
detail later, these values can easily be modified by tweaking the
source code, so a broad range of possibilities can be tried before
resorting to a user prepared \texttt{related.mat}.

\begin{appendix}

\section{Some Kind of Appendix, Maybe} \label{app:Cyclic}

This is just a place holder, in case we end up needing some sort of appendix. 



\end{appendix}

%%%------------------------------------------------------------------------------------
%%%------------------------------------------------------------------------------------
\bibliographystyle{agsm}
\bibliography{pa_ref}
\end{document}

